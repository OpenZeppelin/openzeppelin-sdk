'use strict';
require('../../setup');

import { accounts, defaultSender } from '@openzeppelin/test-environment';

import Contracts from '../../../src/artifacts/Contracts';
import { contractMethodsFromAbi, ContractMethodMutability as Mutability } from '../../../src/artifacts/Contract';

import { expect } from 'chai';

const ContractWithStructInConstructor = Contracts.getFromLocal('WithStructInConstructor');
const ContractWithConstructorImplementation = Contracts.getFromLocal('WithConstructorImplementation');
const InitializableMock = Contracts.getFromLocal('InitializableMock');
const SampleSolc06 = Contracts.getFromNodeModules('mock-solc-0.6', 'Sample');

describe('Contract', function() {
  const [account] = accounts;
  const txParams = { from: account };

  describe('methods', function() {
    /*
     * It seems that truffle/web3 cannot parse correctly a struct that
     * is sent as an argument to a constructor, thus there is no way
     * of asserting the struct attributes/values in terms of equality,
     */
    describe('#new', function() {
      describe('arguments parsing', function() {
        context('when sending only a struct', function() {
          it('instantiates the contract', async function() {
            const args = { buz: 10, foo: 'foo', bar: 'bar' };
            const instance = await ContractWithStructInConstructor.new(args);

            (await instance.methods.buz().call()).should.not.be.null;
            (await instance.methods.foo().call()).should.not.be.null;
            (await instance.methods.bar().call()).should.not.be.null;
            (await instance.methods.sender().call()).should.eq(defaultSender);
          });
        });

        context('when sending a struct and txParams', function() {
          it('instantiates the contract', async function() {
            const args = { buz: 10, foo: 'foo', bar: 'bar' };
            const instance = await ContractWithStructInConstructor.new(args, txParams);

            (await instance.methods.buz().call()).should.not.be.null;
            (await instance.methods.foo().call()).should.not.be.null;
            (await instance.methods.bar().call()).should.not.be.null;
            (await instance.methods.sender().call()).should.eq(account);
          });
        });
      });
    });

    describe('#at', function() {
      beforeEach('deploying contracts', async function() {
        this.instance1 = await ContractWithConstructorImplementation.new(10, 'foo', txParams);
        this.instance2 = await ContractWithConstructorImplementation.new(20, 'bar', txParams);
      });

      it('creates a copy of the instance', async function() {
        const instance1 = ContractWithConstructorImplementation.at(this.instance1.address);
        const instance2 = ContractWithConstructorImplementation.at(this.instance2.address);
        instance1.address.should.not.eq(instance2.address);
        instance1.options.address.should.not.eq(instance2.options.address);
        (await instance1.methods.text().call()).should.eq('foo');
        (await instance2.methods.text().call()).should.eq('bar');
      });
    });
  });

  describe('standalone functions', function() {
    describe('#contractMethodsFromAbi', function() {
      context('solidity 0.5', function() {
        /* public methods in contract:
         * initialize()
         * initializeNested()
         * initializeWithNested(uint256)
         * nonInitializable(uint256)
         * fail()
         */
        context('when querying constant methods', function() {
          beforeEach('set methods', function() {
            this.methods = contractMethodsFromAbi(InitializableMock, Mutability.Constant);
          });

          it('returns an array of methods including autogenerated getters', function() {
            expect(this.methods).to.have.lengthOf(3);
            this.methods.forEach(method => expect(method.type).to.eq('function'));
          });

          it('returns methods without initializers', function() {
            const methods = this.methods.filter(({ hasInitializer }) => !hasInitializer);
            expect(methods).to.have.lengthOf(3);
            expect(methods.map(m => m.name)).to.have.members(['x', 'initializerRan', 'fail']);
          });

          it('sets selectors', function() {
            const selectors = this.methods.map(({ selector }) => selector);
            expect(selectors).to.include('x()', 'initializerRan()', 'fail()');
          });
        });

        context('when querying non-constant methods', function() {
          beforeEach('set methods', function() {
            this.methods = contractMethodsFromAbi(InitializableMock, Mutability.NotConstant);
          });

          it('returns methods without initializers', function() {
            const methods = this.methods.filter(({ hasInitializer }) => !hasInitializer);
            expect(methods).to.have.lengthOf(1);
            expect(methods[0].name).to.eq('nonInitializable');
          });

          it('returns methods with initializers', function() {
            const methods = this.methods.filter(({ hasInitializer }) => hasInitializer);
            expect(methods).to.have.lengthOf(3);
            expect(methods.map(m => m.name)).to.have.members(['initialize', 'initializeNested', 'initializeWithX']);
          });

          it('returns an array of methods', function() {
            expect(this.methods).to.have.lengthOf(4);
            this.methods.forEach(method => expect(method.type).to.eq('function'));
          });

          it('sets selectors', function() {
            expect(this.methods.map(m => m.selector)).to.have.members([
              'initialize()',
              'initializeNested()',
              'initializeWithX(uint256)',
              'nonInitializable(uint256)',
            ]);
          });
        });
      });

      context('solidity 0.6', function() {
        it('queries constant methods', function() {
          const methods = contractMethodsFromAbi(SampleSolc06, Mutability.Constant);
          expect(methods.map(m => [m.name, m.type, m.selector])).to.have.deep.members([
            ['value', 'function', 'value()'],
            ['samplePure', 'function', 'samplePure(uint256)'],
            ['sampleView', 'function', 'sampleView()'],
            ['basePure', 'function', 'basePure()'],
          ]);
        });

        it('queries non-constant methods', function() {
          const methods = contractMethodsFromAbi(SampleSolc06, Mutability.NotConstant);
          expect(methods.map(m => [m.name, m.type, m.selector])).to.have.deep.members([
            ['samplePayable', 'function', 'samplePayable()'],
            ['sampleNonpayable', 'function', 'sampleNonpayable(uint256)'],
            ['basePayable', 'function', 'basePayable()'],
          ]);
        });
      });
    });
  });
});
