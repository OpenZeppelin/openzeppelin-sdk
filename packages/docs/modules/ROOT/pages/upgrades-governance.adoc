[[upgrades-governance]]
= Upgrades governance

[[introduction]]
== Introduction

The OpenZeppelin SDK provides the chance to have upgradeable smart contracts which follows the immutability rules guaranteed by the Ethereum blockchain. However, it is desirable to have a mechanism that allows all parties involved to decide on whether a contract should be upgraded or not, instead of having an unilateral decision.

Given that there are many projects already working on really good solutions to achieve decentralized governance, we've been exploring some of them to study how they can be integrated with the OpenZeppelin SDK to manage contract upgrades.

In this case, we will use a multisignature wallet.

[[getting-started]]
== Getting started

A multisig is a contract that can execute arbitrary transactions, with the restriction that a certain number of owners must agree upon them. We highly recommend using the https://github.com/gnosis/MultiSigWallet[Gnosis MultiSig Wallet], which was https://blog.openzeppelin.com/gnosis-multisig-wallet-audit-d702ff0e2b1e[audited by the Zeppelin team] and has a https://wallet.gnosis.pm/[useful dApp] for submitting and confirming transactions. You can use it easily to deploy your own multisig wallet.

image:https://lh5.googleusercontent.com/CqtaZkTZqJ_jT9vdQdPj-CNj304InYItfIBi5LnWrnsySGNOpN0HVu9DFIZbE1TpIq20ZN-3bAB1fNhFQiD_fTKqoLFyzQR7bLmmyfMJZABQMYMOnOzfTrsAkk_sgxeEQTriSJAB[image]

Once inside your OpenZeppelin SDK project, let's suppose we have an arbitrary contract called `MyContract`. Now let's see how we can create an upgradeable instance of it being handled by a multisig wallet. In order to do that, we will need first to register this contract, push it to the network and create a new upgradeable instance of it as we explained in the previous sections:

[source,console]
----
openzeppelin add MyContract
openzeppelin push -n ropsten
openzeppelin create MyContract -n ropsten
----

We have our contract deployed to the `ropsten` network, with an instance of our `MyContract` contract up and running. At this point, the ownership of the project is being controlled by the deployer account, which can unilaterally decide when to upgrade any of its contracts.

[[transferring-control]]
== Transferring control

Since we want to avoid having a single account with full control over our `MyContract` instance, we’ll transfer control of it to our multisig contract. To do this, we’ll use the `set-admin` command to yield control to the multisig account.

[source,console]
----
openzeppelin set-admin [MYCONTRACT_ADDRESS] [MULTISIG_ADDRESS] -y
----

NOTE: Please remember to replace `[MYCONTRACT_ADDRESS]` by the address of the upgradeable instance of `MyContract` we created above. Additionally, `[MULTISIG_ADDRESS]` should be replaced by the address of your multisig wallet contract.

IMPORTANT: The `-y` option is mandatory to carry out this action. Bear in mind that this could be an irreversible operation in case you specify an incorrect admin address.

Now, if we want to upgrade our `MyContract` instance to a new version, we’ll need to perform the operation from the multisig contract. Note that we have transferred only the ownership of our `MyContract` instance. If we had created more instances of `MyContract`, or of any other contract, they would still be under control of the deployer account.

The same applies to our OpenZeppelin SDK app. This allows us to keep interacting with our project via the CLI, by creating new instances or registering new logic contracts, as we’ll be doing in the next step.

[[uploading-a-new-version]]
== Uploading a new version

Let’s suppose we extend the functionality somehow. The first step is to upload this new logic contract to the blockchain. Since the whole project is still managed by our deployer account, we can easily do that from the CLI by running:

[source,console]
----
openzeppelin add MyContract
openzeppelin push
----

Now that our new logic contract is uploaded to the network, we can proceed to upgrade our `MyContract` instance.

[[upgrading-our-contract-instance]]
== Upgrading our contract instance

At this point, if we attempt to upgrade our `MyContract` instance to the new version through the CLI, we’ll get an error since the deployer account no longer has upgrade rights over the contract instance. We need to go through the multisig to perform this operation, as the CLI’s account.

Let’s submit a transaction to the multisig wallet for our contract instance to be upgraded. We can do this from the Gnosis dApp by including the https://gist.github.com/spalladino/d25c41c19a538ae918735e5b1c07db07[proxy's ABI] and choosing to invoke `upgradeTo`. We also need to supply the address of the new implementation, which can be found in the output of the last `openzeppelin push` command or in the `.openzeppelin/ropsten.json` file.

image:https://lh3.googleusercontent.com/Wi76B5WGVs8_qGD1GPVYpA5oOF4hEVt1mfl1grCszZRfxRlkPS1PsPxm9-Kpm0NfX0qlmq-5rUNfXdEJrIlH8gJK9TNW7NjlZ_QVqAuv5JZRFW-zQNxATQpA9OapPq_6J85nzTLz[image]

This will create a new transaction in the multisig wallet for the `MyContract` instance to be upgraded to the latest `MyContract` implementation. However, since this requires the approval of at least another multisig owner, the upgrade is still pending.

image:https://lh3.googleusercontent.com/twzAZicQUubRZaPJpj0ZmjnRICKKkC28LyP6p-CgHH15N3ZVqrlOXuptOBR_hRbIqAxLF8K5sW9SnX3QjidDEKZ2fZ8BBdSGZXn_oibjWOm4Vgu1BshMN3zTgWM6KCafAcN2saHI[image]

As soon as another owner of the multisig account confirms this transaction, it will be executed on the spot and our `MyContract` instance contract will be upgraded to the desired version, allowing us to make use of the new functionality we built.
